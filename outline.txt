import { Contract, Context } from "cosmwasm";

// we store the hashes to the notes in the contract state
interface State {
  notes: string[];
}

// this is the initial state of the contract
const init = (): State => {
  return {
    notes: [],
  };
};

// we allow the user to deposit Juno and submit a hash of the note
// the note is generated randomly by the user, and they must provide a proof of it
// to redeem the Juno later
export function deposit(ctx: Context, msg: DepositMsg): void {
  const state = ctx.getState<State>();
  state.notes.push(msg.note_hash);
  ctx.setState(state);
  ctx.transfer(msg.sender, msg.amount);
}

// this message is used to deposit Juno and submit a hash of the note
interface DepositMsg {
  note_hash: string;
  amount: number;
  sender: string;
}

// the user can redeem their Juno by providing the proof of the note
export function redeem(ctx: Context, msg: RedeemMsg): void {
  const state = ctx.getState<State>();
  if (!state.notes.includes(msg.note_hash)) {
    throw new Error("Invalid note hash");
  }
  if (!verifyProof(msg.note, msg.proof)) {
    throw new Error("Invalid proof");
  }
  // remove the hash from the state
  state.notes = state.notes.filter((n) => n !== msg.note_hash);
  ctx.setState(state);
  // transfer the Juno to the specified recipient
  ctx.transfer(msg.recipient, msg.amount);
}

// this message is used to redeem the Juno by providing the proof of the note
interface RedeemMsg {
  note_hash: string;
  note: string;
  proof: string;
  amount: number;
  recipient: string;
}

// this function verifies the proof of the note
function verifyProof(note: string, proof: string): boolean {
  // add code to verify the proof here
  return true;
}

